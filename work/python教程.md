# Python 教程
    Python 仅是高级语言中的一种，你可能也听说过其他的高级编程语言，比如 C,C++,Perl, 和 Java。
    也有一些低级语言，有时也被称为机器语言或者汇编语言。
    用 Python 编写的程序是通过解释器执行的。有两种使用解释器的方式：交互模式和脚本模式。
    在交互模式下，你可以输入 Python程序，然后解释器输出结果。
    锯齿符，>>> 
    是提示符, 解释器用它来表明自己已经准备好了，如果你输入 1 + 1, 解释器显示 2。
    Python 脚本的扩展名为.py
    
## Kittenbot下使用Python3编程的教程
[参考](http://learn.kittenbot.cn/zh_CN/latest/scratch3_python3/index.html)

    1. Kittenblock中的python3
    1.1. 海龟作图的准备工作
    1.2. 第一个图形化的绘图程序
    1.3. 将图形化方块转换成python并重新执行
    1.4. 直接拖方块到python编辑区
    2. 基础绘图
    2.1. LOGO语言
    2.2. 让bug动起来
    3. 画笔控制
    3.1. 抬笔落笔的控制
    3.2. 改变画笔的颜色
    3.3. 改变画笔的大小
    3.4. 画一个圆
    3.5. 函数化
    
这部分是Kittenbot所有跟Micropython相关的教程

    1. 开始前的准备
    1.1. 什么是python
    1.2. 为什么要学习python
    1.3. 为什么使用Kittenblock学习python
    1.4. 下载和安装Kittenblock
    2. Microbit快速开始
    2.1. Microbit主板基本介绍
    2.2. 打开软件和连接Microbit
    2.3. 显示第一个图形
    3. 2.5 Micropython在线执行
    3.1. Micropython在线执行代码
    3.2. 跟Micropython解释器对话
    4. 5x5矩阵屏的花式玩法
    4.1. Microbit显示模块介绍
    4.2. Microbit显示不同的表情
    4.3. Microbit显示自定义图案
    4.4. Microbit显示动画特效
    4.5. 课后作业
    5. 显示字符和数字
    5.1. 如何查看代码错误
    5.2. 用矩阵屏显示自定义文字和数字
    6. Python基础篇1
    6.1. Python基本计算和基本函数
    6.2. 查看python的对象
    7. Python基础篇2
    7.1. python的import方法
    7.2. python的数组(列表)类型
    7.3. python的字典类型
    7.4. python的其他数学函数
    8. Microbit按键和程序流程
    8.1. Microbit按键函数
    8.2. python的循环与条件控制
    8.3. python逻辑表达式和作用域介绍
    9. Python程序流程-高级篇
    9.1. for循环
    9.2. if ... else ...
    9.3. 条件判断的混合用法
    9.4. 课后作业
    10. 蜂鸣器与音乐
    10.1. 电路接线
    10.2. 图形化编程
    10.3. music模块编程
    10.4. 自定义音乐
    10.5. 播放音调
    11. 加速度计
    11.1. 加速度计原理
    11.2. 读取加速度大小
    11.3. 用Microbit做一个量角器

## 编程猫 可视化python编程

    编程猫在线体验地址：  https://wood.codemao.cn/
    本地编辑器客户端下载：https://python.codemao.cn/
    
    支持在线运行的库包括：
        math             数学运算库
        random           随机数模块
        turtle           小乌龟
        time (partial)   时间模块
        random (partial)
        urllib (partial)
        unittest
        image            图像模块
        DOM (partial)
        re (partial)
    除此之外，如果想运行其他的库，也可以下载安装PC客户端“海龟编辑器”，本地运行Python3！
 



## 高级 代码编程
[ 与孩子一起学编程 ](https://github.com/Ewenwan/python.Hello-World-Computer-Programming-for-Kids-and-Other-Beginners)

中文书籍 链接：https://pan.baidu.com/s/1ZtNMKep-Zl62hKN18HzWUw 提取码：70us 

[SIGIA_4P学习 AIpython学习](https://github.com/Ewenwan/ShiYanLou/blob/master/learn_python/SIGIA_4P%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.md)


[think python 思考 Python 像计算机科学家一样思考 1.1.22](https://github.com/wolfpython/thinkpython/blob/master/thinkpython/tex-zh/book.pdf)

> 什么是程序?

    程序就是指令集合，这些指令说明了如何执行计算。
    计算可能是数学上的，例如解决等式组或者计算多项式的平方根。
    但是也可以是符号计算，比如搜索替换文件的文本或者 (非常奇怪) 编译一个程序。
    不同的语言有一些细节上的差异。
    但是他们有一些共有的指令：
        1.输入： 从键盘获取数据，文件，或者从其他设备。
        2.输出： 在显示器上显示数据或者把数据输出到文件或其他设备。
        3.数学运算: 做基本的数学操作像加法和乘法。
        4.条件执行： 检查条件，然后执行正确的语句。
        5.循环： 重复执行一些动作，通常有些变化。
        
    编程就是把复杂庞大的任务分解为一系列的小任务，直到这些小任务简单到可以用这些基本的指令表示。
    
> 编程语言

    诗歌：
         单词的运用既是为了语义的需要，也是为了音韵的需要，整首诗创造了一种情感共鸣。
         二义性不仅很常见，而且常常是故意安排的。
    散文：
         单词的字面意思更加重要，结构也表达了更多的意思。
         散文比诗歌更容易分析，但是仍然具有二义性。
    程序：
         计算机程序是无二义性。
         可以通过分析标记和结构完全理解。
         
> 术语表

    high-level language 高级语言，像 Python 一样的程序设计语言，被设计让人们易读易写程序。
    low-level language 低级语言，设计让计算机容易执行的程序设计语言；也叫做“机器语言”或者“汇编语言”。
    portability 可移植性，程序可以在一台或多台电脑执行的属性。
    interpret 解释，逐行逐行解释执行用高级语言编写的程序。
    compile 编译，把用高级语言编写的程序转换成低级语言。
    source code 源码： 未编译的高级语言编写的程序。
    object code 目标代码： 编译器转换程序后的输出。
    executable 可执行代码： 目标代码的别名，可以被执行。
    prompt 提示符： 解释器显示的字符，表明做好准备让用户输入。
    script 脚本： 存储在文件中的程序。
    interactive mode 交互模式： 一种通过输入命令和表达式的使用 python 解释器的方式。
    script mode 脚本模式： 一种使用 Python 解释器的方式，Python 解释器读取脚本中的语句执行。
    program 程序： 指明计算的指令集合。
    algorithm 算法 求解一类问题的通用过程。
    bug: 程序的错误。
    debugging 调试： 发现，去除程序错误的过程。
    syntax 语法 程序的结构。
    syntax error 语法错误： 使程序不能正确解析的错误。
    exception 异常： 程序在运行时发现的错误。
    semantics 语义： 程序的含意。
    semantics error 语义错误： 程序中的错误，使计算机执行另外的程序。
    natural language 自然语言： 人们日常交流用的语言，自然发展的。
    formal language 正式语言：代表数学思想或者计算机程序，所有的程序设计语言都是正式语言。

# 小试牛刀===

> 命令 计算机 说话:   print 打印 命令
```python
>>> print("你好")
你好
# Python2 
# print "你好"
# 在Python3.0中，print 是一个函数，不是一个语句，所以语法是 print("你好")。

```

> 让计算机 算 算术题：
```python
# 数字运算====
>>> print(10 + 9)
19
>>> print(9 * 9)
81

# 字符的运算=======
>>> print("小明" + "小红")   # 排队，老鹰捉小鸡
小明小红

# 孙悟空 三根猴毛 特技 变 子子孙孙   牛魔王 也有 这个 特技
>>> print('孙悟空'*10)
孙悟空孙悟空孙悟空孙悟空孙悟空孙悟空孙悟空孙悟空孙悟空孙悟空

```
> 小明到饭店吃饭饭
```python
print('我叫小明')
print('我喜欢吃汉堡')
print('汉堡 '*5)
print('我吃饱了')
print('付钱 ')
print(10*5)
```


> 电脑出数字，小朋友猜数字
```python
# -*- coding: utf-8 -*-
# 电脑出数字，小朋友猜数字
# 另外一个 小朋友出数字，电脑猜数字
import random # 大脑 产生随机数

secret = random.randint(1,100)# 电脑出的一个整数，范围1~99
guess = 0 # 小朋友猜的数字
tries = 0 # 尝试的次数

print("小朋友，你将有6次机会猜出我出的数字，范围在1~99之间，开始吧")

# 做游戏，游戏结束的两个条件，1.小朋友猜对了；2.6次机会用完了
while guess != secret and tries < 6:  # 只要没猜对且机会没用完，游戏一直进行
    guess = input("小朋友这次猜多少?")  # 获取小朋友猜的数字 
    if guess < secret:  # 猜小了
        print("小了")
    elif guess > secret:# 猜大了
        print("大了")
    tries = tries + 1
        
if guess == secret:
    print("恭喜你，小朋友，你猜对了")
else:
    print("不要灰心，小朋友，看看答案是多少吧 ")
    print(secret)
```

# 内存和变量
    对变量的操作是编程语言最强大的特征之一。
    
    输入 ----接收外界数据(人类的 眼睛视觉、耳朵听觉、鼻子嗅觉、皮肤触感)
    处理 ----计算机小同学大脑处理数据---小明思考问题
    输出 ----可视化(人类的嘴巴说话、四只运动)
    
    上述猜字谜游戏 中使用的
    guess = input("小朋友这次猜多少?") 就是获取 外界输入的信息
    计算机使用 内存单元 记录 输入的内容 并给它们命名
    使用 guess 该 该内容 命名
```python
>>> student = "小明" # 字符串
>>> print(student)   # 输出 打印信息 到显示器上显示
小明
>>> age = 8     # 整数 数字
>>> print(age)  # 8岁 
8
>>> student = "小红"  # 名字指向了 另一个同学 变化多端
>>> print(student)   # 输出 打印信息 到显示器上显示

>>> age = age + 1  # 全新的我，长大一岁
>>> print(age)     # 9岁 
9

# 命名中的学问
Xiaoming  和 xiaoming一样么?   1.区别大小写
teacher 
teacher2
2teacher        必须以字母或者_开头
teacher_2       除了字母、数字、_外不能用其他字符
teaChen

```

# 基本数学运算
1.加 +   2.减 - 3.乘 *  4.除 //  5.整数除法 /   6.取余数 %  7. 指数运算 ** 8. 
```python
>>> 5/2
2
>>> 5//2
2.5
>>> 5.0/2
2.5
>>> 5%2
1
>>> 7 + 3    加数7 + 被加数3 
10

>>> 2 + 3 * 4
14
>>> (2 + 3) * 4
20

>>> 3*3*3*3
81
>>> 3 ** 4  四个 3 相乘

# 自增、自减、自乘...
>>> age = 8
>>> age += 1
>>> print(age)
>>> 9
>>> age -= 2
>>> print(age)
>>> 7
>>> age *= 3
>>> print(age)
>>> 21

# 科学计数法
>>> 3e2 # 3 乘以 10 的平方
300     # 3 * 10*10


# 格式化打印
number = 12.67
print('整数 %i, 小数 %.1f,科学计数法 %e' % number,number,number)

```

# 数据类型
    内置函数实现类型强转
    整数int()    从一个字符串或整数创建一个新的整数(自然数+0+负自然数) 
    小数float()  从一个字符串或整数创建一个新的小数(浮点数 float 浮动的)
    字符str()    从一个任意类型的数创建一个新的字符串
```python
a=24        # 整数转浮点数
b=float(a)
print(b)
>>> 24.0
print(a)
>>> 24

c=38.6       # 浮点数转整数
d=int(c)     直接砍掉小数部分
print(d)
>>> 38
print(c)
>>> 38.6

h='99.9'    # 字符串转小数
i=float(h) 
print(i)
>>> 99.9
print(h)
>>> '99.9'

# 数据类型 
type(h) # 查看 数据 更多的信息
>>>
<type 'str'>
字符串属于类型 str，整数属于类型 int,带小数点的数字属于 float 类型。
```


# 输入
```python
# 下朋友按键盘，这里会得到 按下的字符数组等
someName = raw_input()  

print('小朋友，你好，请输入你的名字')
someBody = raw_input()
print('你好 ',someBody,' 今天过得怎么样')

# 更简单的，使用 raw_input直接打印提示语
someBody = raw_input('小朋友，你好，请输入你的名字')

# 输入数据
ages = int(raw_input('小朋友，你好，请输入你的年龄'))
print('小朋友都长这么大了','真好')

# 3.0以后的版本， input() 得到的也只是字符串，需要使用一些函数进行转换才能得到数字


# 从互联网 中的一个文件 得到输入=====
# python2.0+========
import urllib
file = urllib.urlopen('http://helloworldbook.com/data/message.txt')
message = file.read()
print message 
# python 3.0+=======
import urllib.request
file = urllib.request.urlopen('http://helloworldbook.com/data/message.txt')
ssage = file.read()
print message 

```


# GUI 图形用户界面，可是化界面，人机交互界面，计算机的大脸蛋^_^

```python
# 使用 easygui 包，利用这个模块可以很容易地建立简单的 GUI
# 使用前需要先安装该模块
import easygui as eg # 导入该模块

# 显示一个带有 OK按钮的 简单消息框=======
eg.msgbox('Hello World!')
# 点击消息框上的 OK 按钮，该消息框会关闭

# 返回用户 的反馈信息
user_response = eg.msgbox('Hello World!')
print(user_response)

# 按钮框=======buttonbox============
flavor = eg.buttonbox("What is your favorite ice cream flavor?", choices = [' Vanilla', 'Chocolate', 'Strawberry'])
# choices 列表选择框，三个按钮
# 再 显示消息框，显示 小朋友选择的 最爱
eg.msgbox("You picked " + flavor)  


# 选择框====choicebox===============
flavor = eg.choicebox("What is your favorite ice cream flavor?", choices = ['Vanilla', 'Chocolate', 'Strawberry'])
# 列表选择框
eg.msgbox ("You picked " + flavor) 

# 字符文本输入框====enterbox=========
flavor = eg.enterbox('what is your favorite ice cream flavor?', default = 'Vanilla')# 带默认字符
# 会出现一个文本输入框，按OK完成输入内容
easygui.msgbox('you entered ' + flavor) 


# 整数数字文本输入框====integerbox=======
age = eg.enterbox('what is your age')
# 输入整数，不支持输入小数，可以使用上面的文本输入，再使用float()转换到小数
# 会出现一个文本输入框，按OK完成输入内容
easygui.msgbox('you age ' + str(age)) 
```
> 可视化猜数字游戏…
```python
电脑出数字，小朋友猜数字

# -*- coding: utf-8 -*-
# 电脑出数字，小朋友猜数字
# 另外一个 小朋友出数字，电脑猜数字
import random # 大脑 产生随机数
import easygui as eg # 可视化界面

secret = random.randint(1,100)# 电脑出的一个整数，范围1~99
guess = 0 # 小朋友猜的数字
tries = 0 # 尝试的次数

# print("小朋友，你将有6次机会猜出我出的数字，范围在1~99之间，开始吧")
eg.msgbox('小朋友，你将有6次机会猜出我出的数字，范围在1~99之间，开始吧')

# 做游戏，游戏结束的两个条件，1.小朋友猜对了；2.6次机会用完了
while guess != secret and tries < 6:  # 只要没猜对且机会没用完，游戏一直进行
    # guess = input("小朋友这次猜多少?")  # 获取小朋友猜的数字 
    guess = eg.integerbox('What is your guess?')

    if guess < secret:  # 猜小了
        # print("小了")
        eg.msgbox('小了')
    elif guess > secret:# 猜大了
        # print("大了")
        eg.msgbox('大了')
    tries = tries + 1 # 用掉一次机会
        
if guess == secret:
    eg.msgbox("恭喜你，小朋友，你猜对了")
else:
    eg.msgbox("不要灰心，小朋友，看看答案是多少吧 " + str(secret))
    # print(secret)
    
```


# 判断判断判断 一修哥 福尔摩斯 田忌赛马 做决策 

```python
# 数1 == 数2  判断两个数是否相等   
# 数1 != 数2  不等于判断
# 数1 >  数2  大于判断
# 数1 <  数2  小于判断
>=  大于等于
<=  小于等于

# 区间判断
5 < age < 8
5 <= age <= 8

age = float(raw_input("小朋友输入你的年龄:"))
if age > 10:
    print('小朋友，你超过10岁啦')
    # elif
    # 嵌套条件 if ... else ...
else:
    print('小朋友还比较小哦')


# 结合 逻辑判断 
条件1 and 条件2    # 与，条件1 与 条件2都必须成立，才进入该分支
条件1 or 条件2     # 或，若条件1每成立，则查看条件2，有一个成立，就进入该分支
not 条件           # 非

```

# 循环，转圈圈，呼啦圈
```python
for id in [1,2,3,4,5]:
    print('你好', id)
>>>
你好 1
你好 2
你好 3
你好 4
你好 5

for id in range(1,5):
    print(id, '倍 8 = ', id*8)
>>>
1 倍 8 = 8
2 倍 8 = 16
3 倍 8 = 24
4 倍 8 = 32

# range(1, 5) 给出的列表是 [1,2,3,4]
# range(5) 给出的列表是  [0,1,2,3,4]
# range(l, 10, 2)  给出的列表是 [1,3,5,7,9]
# range (5, 26, 5) 给出的列表是 [5,10,15,20,25]
# range(10, 5, -1) 给出的列表是 [10,9,8,7,6]


while 条件:
    循环体;
    ...
    continue   # 跳过一次循环中的部分代码
    break      # 结束循环，条件不成立时也会结束循环
    
'''
while 语句的执行流。
1. 计算条件的值，产生结果 True 或者 False。
2. 如果条件为假，退出 while 循环, 继续执行下一条语句。
3. 如果条件为真，执行语句体里的语句，然后回到步骤一。
'''

# 使用牛顿迭代法 求f(x)=0的解   x=x0-f(x0)/f'(x0)
# 利用求 f(x) = x^2-a =0 ,求解a的平方根
# x = x0 -(x0^2-a)/(2*x0)
def my_square(num):
    x0 = num
    result = num
    while True:
        result = x0 - (x0**x0-num)/(2*x0
        if math.abs(result-x0) < 0.0000001:
           return result
        else:
            x0=result  


```

# 列表====清单===购物清单===家庭成员列表

```python
shoppingList = ['苹果','香蕉','饼干'] # 购物清单
family = ['妈妈','爸爸','小明','小红'] # 家庭成员列表
luckyNumber = [5,6,8,10,12,666,888]   # 幸运数字
friends = [] # 朋友列表
friends.append('明明') # 添加 明明 这位朋友 friends = ['明明']
friends.append('慧慧') # 添加 慧慧 这位朋友 friends = ['明明','慧慧']
print(friends)
>>>
['明明','慧慧']
print('小明的第一位朋友', friends[0]) # [] 访问朋友
print('小明的第二位朋友', friends[1])

# 列表切片 beg:end  索引范围为 beg,beg+1,...,end-1.
# [:] 所有元素
# [beg:]  索引范围为 beg,...,最后
# [:end]  索引范围为 0,...,end-1

# 修改 朋友
friends[1] = '小慧' # 慧慧该名字了，改成了小慧

# 增加元素==========
append() 向列表末尾增加1个元素   
     friends.append('小刚')          # friends = ['明明','慧慧','小刚']
extend() 向列表末尾增加多个元素  
     friends.extend(['小涛','小亮']) # friends = ['明明','慧慧','小刚','小涛','小亮']
insert() 在列表中的某个位置增加1个元素 
     friends.insert(2,'小磊')        # friends = ['明明','慧慧','小磊','小刚','小涛','小亮']

# 删除元素====
remove(指定元素)  删除指定元素
     friends.('慧慧') # 和 慧慧 闹不开心了 friends = ['明明','小磊','小刚','小涛','小亮']
del friends[2] 删除指定 索引位置
     # friends = ['明明','小磊','小涛','小亮']
pop(指定索引位置) 删除指定索引位置
     friends.pop()  # 删除最后一个元素      friends = ['明明','小磊','小涛']
     friends.pop(0) # 删除索引为0位置的元素 friends = ['小磊','小涛']

# 查找 
in 关键帧
    if '小涛' in friends:
        print('有小涛')
    else
        print('无')
index() 查找索引  
print friends.index('小磊') 
>>> 
0


循环处理列表
friends = ['明明','慧慧','小磊','小刚','小涛','小亮']
print('小明的朋友有:')
for friend in friends
    print(friend)

>>> 
小明的朋友有:
明明
慧慧
小磊
小刚
小涛
小亮


# 列表排序
.sort()
.reverse() # 正弦排序后 再 反着排列，逆序排列
.sort(reverse = True)  # 直接传递参数，逆序排列

# 排序函数
有序列表 = sorted(列表对象实例) #返回一个有序列表，原列表不改变

# 二维列表====



# 字符串===纯字符列表====

```

# 字典 新华字典 查单词 查汉字  dictionary 字典： 键集合到对应值的映射
    字典像列表一样，但是更一般。
    列表的索引必须是 整数，但字典的索引（键）几乎可以是任何类型。
    按 偏旁部首/拼音 查汉字
    
    可以把字典当作是索引集合（关键字）和值集合之间的映射。每一个关键字对应一个值。
    关键字和对应的值称为键 -值对，或者项。
    
    key-value pair 键值对： 键 --值映射的表示。
    
    
    
    dict 函数创建一个空字典。
    由于 dict 是内建函数名，所以，我们应该避免使用它作为变量名。
    
```python
>>> eng2sp = dict()
>>> print(eng2sp)
{}
# 大括号{}, 代表空字典。向字典中添加一个项，可以使用方括号：
>>> eng2sp['one'] = 'uno'
# 这行代码创建了一个从关键字'one' 到值'uno' 的映射。
# 如果再次输出字典, 可以看到关键字－值对，和他们之间的冒号：
>>> print(eng2sp)
{'one': 'uno'}
# 上面输出的格式，也是输入格式。比如，可以创建一个拥有三项的字典：
>>> eng2sp = {'one': 'uno', 'two': 'dos', 'three': 'tres'}
# 但是如果输出 eng2sp, 你可能会感到惊讶：
>>> print(eng2sp)
{'one': 'uno', 'three': 'tres', 'two': 'dos'} 
# 顺序变了，一般来说，字典项的顺序是随机的。
# 因为字典的元素是不是通过索引来获取的。可以使用关键字来查询对应的值。
>>> print(eng2sp['two'])
'dos'
# 关键字'two' 总是对应值'dos', 所以项的顺序没有什么关系。

# len 函数对于字典也是适用的。它返回键－值对的数目：
>>> len(eng2sp)
3

# 英文单词的  26个字母统计  直方图统计 =======
def histogram(s):
    d = dict()
    for c in s:
        if c not in d:
            d[c] = 1
        else:
            d[c] += 1
    return d
    
>>> h = histogram('brontosaurus')
>>> print(h)
{'a': 1, 'b': 1, 'o': 2, 'n': 1, 's': 2, 'r': 2, 'u': 2, 't': 1}

```

# 元组 tuple
    元组是一组序列的值。
    元组中的值可以是任何数据类型，使用整数作为下标，
    在这个方面元组很像列表。
    但是一个主要的区别是元组是不可改变的。
    
```python
>>> t = 'a', 'b', 'c', 'd', 'e'
通常用括号包含元组，虽然这不是必要的：
>>> t = ('a', 'b', 'c', 'd', 'e')
要创建只含一个元素的元组，你需要包含最后的逗号：
>>> t1 = 'a',
>>> type(t1)
<type 'tuple'>
在括号中的值不是元组：
>>> t2 = ('a')
>>> type(t2)
<type 'str'>

创建元组的另一个方式是使用内置函数 tuple。
当没有参数时，函数创建一个空的元组：
>>> t = tuple()
>>> print(t)
()

```

# 函数---积木---魔法黑盒子---法宝---
    函数是带有函数名的一系列执行计算的语句, 
    当定义一个函数，我们指定一个函数名和一系列的语句。
    然后，就可以通过函数名调用函数。
    math 数学函数库
    
    增量开发： 一种程序开发的方法，通过每次添加测试少量代码来避免程序的调试。
    增量开发是通过每次测试一小部分代码的方法来避免过长的调试过程。
    增量开发可以节约你很多调试的时间   
    这个过程的关键在于：
    1. 编写程序时每次只做少量修改，在任何时刻如果出错，你可以很方便的定位错误。
    2. 使用临时变量记录中间过程值，这样你可以显示并检查它们。
    3. 当程序正常工作后，你可能需要删除一些脚手架代码或者合并
       多个语句为一个复合语句。
       注意保持程序的可读性。

```python
def function_name(参数列表): # header 函数头： 函数定义的第一行。 parameter 形参
    ...                     # body 函数体： 函数定义里面的一系列语句。
    return 返回参数
    # fruitful function 结果函数： 有返回值的函数。
    # void function 虚无函数： 没有返回值的函数。
    # 死区代码： 程序中无法执行到的代码，通常因为出现在 return 语句的后面。
    # 脚手架： 在程序开发过程中使用的代码，并不出现在最终版本中。
    # 守护人： 使用条件语句检查错误并处理可能出错的情况的编程模式。
    
# 计算 两点之间的距离
# 使用增量开发 策略
# 点(x1,y1) (x2,y2) dis = sqrt((x1-x2)^2 +(y1-y2)^2)
# 1. 写出函数框架======
def distance(x1,x2,y1,y2):
    return 0.0
# 2. 计算部分 内容=====
def distance(x1,x2,y1,y2):
    # 临时变量： 在复杂的计算过程中用来记录中间值的变量。
    dx = x1 - x2
    dy = y1 -y2
    print('x横坐标差值 ',dx)
    print('y纵坐标差值 ',dx)
    return 0.0
# 3. 计算平方 ========
def distance(x1,x2,y1,y2):
    dx = x1 - x2
    dy = y1 -y2
    dsquare = dx**2 + dy**2
    print('距离平方 ',dsquare)
    return 0.0
# 4. 再开方获取最终结果========
def distance(x1,x2,y1,y2):
    dx = x1 - x2
    dy = y1 -y2
    dsquare = dx**2 + dy**2
    import math
    result = math.sqrt(dsquare)
    print('距离 ',result)
    return result
    
# 布尔函数 返回 正确 True 或 错误 False
    
# 变量作用域
全局 global  公有
nonlocal非公非私
局部 local   私有



# 函数递归调用---汉诺塔游戏
```


# 对象  属性(外观、大小、颜色、味道) 方法(子功能、各个小的特技、技能)
    Python 是一门面向对象的编程语言，意味着它提供很多特点支持面向对象编程。
    1.程序由对象定义和函数定义组成，大多数的计算都在操作对象过程中进行。
    2.每个对象定义都和现实世界的一些对象或者概念符合，
        操作对象的函数和现实世界对象的交互方式相一致。
    
```python
class 对象类名字A:
    # 对象初始化函数，比如小明一生下来，有嘴巴、眼睛、耳朵等
    def __init__(self,***,***,***):
        ... 
    def 方法函数名:
        ...
        return ***
    def
    ...
    
# 创建一个 Point 类型，代表二维空间的一个点。    
# class Point:
#    ...

# 定义一个 Time 类，记录当前时间,小时，分钟，秒


# 继承 父类的 特点---遗传----向父母学习---
class B(A):
    ...

```


# 模块 module 模块化 类包 、 函数包、方便使用、造好的轮子、积木桶
```python
import my_module  使用我的模块
import my_module as md
# 命名空间 
frome my_module import *

# 标准模球 
time 时间模块
import time
time.sleep(2)


random 随机数
import random
print(random.randint(0,100)) # 产生0~100之间的数，并打印


```


# Pygame 图形 游戏 包 =======
```python
import pygame
pygame.init()
screen = pygame.display.set_mode([640, 480])
# 你可能会看到屏幕非常迅速地弹出了个窗口(填充为黑色〉
# pygame 的作用就是为了建立游戏。游戏本身不做任何事情，只是与玩家交互。
# 所以 pygame 有一个事件循环(event loop),不断检查用户在做什么，比如 按键 或者 移动鼠标

import pygame
pygame.init()
screen = pygame.display.set_mode([640, 480])
while True:
    pass  # 是一个 python 关键字 ，表示"什么也不做"
    
# 动画开发
# pygame.sprite 动画精灵====
# pygame.event.get() 事件检测 鼠标 按键
#  event.type == pygame.KEYDOWN     按键
# event.type == pygame.MOUSEMOTION  鼠标移动

# 声音
pygame.mixer  # 声音合成器，混音器

# 火箭飞船 燃料 速度 飞行距离 仿真模拟===

```

# PythonCard GUI 组件 按钮 事件处理  菜单   电子宠物仿真，吃饭睡觉饥饿散步玩耍看病
```python
>>>
```

# 文件读写 txt bin   pickle 存储列表数据
    目前我们所见到的大多数的程序都是瞬态的，
    即它们在短时间内运行并输出一些结果，当它们结束时，数据也就消失了。
    如果你再次运行程序，它将从一个初始的状态开始。
    
    另一类程序被称为是持久的，它们长时间运行（或者时刻运行），
    至少将一部分数据记录在永久储存设备（如硬盘）上，当程序关闭并重新启动时，
    它们可以恢复结束前的状态以便继续运行。
    
    程序维护数据最简单的方法是读写文本文件。
    我们已经接触过读取文本文件的程序，在本章中我们将接触写入文本文件的程序。
    记录程序状态的另一个方式是使用数据库。
    在本章节中我给出一个 简单的数据库 和 模块pickle，
    该模块简化了存储数据的过程。
    
```python
# 要写入一个文件，你需要在打开文件时添加第二个参数'w'：
>>> fout = open('output.txt', 'w')
>>> print fout
<open file 'output.txt', mode 'w' at 0xb7eb2410>

# write 方法将数据写入文件。
>>> line1 = "This here's the wattle,\n"
>>> fout.write(line1)
# 文件对象将跟踪位置，如果你再次调用 write，它将在尾部写入新的数据。
>>> line2 = "the emblem of our land.\n"
>>> fout.write(line2)
# 当你完成写入，你可以关闭文件。
>>> fout.close()

# 当前路径
>>> import os
>>> cwd = os.getcwd() # cwd 代表“current working directory”，即当前工作路径
>>> print cwd
/home/dinsdale

# 要得到一个文件的绝对目录，你可以使用 os.path.abspath：
>>> os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'

# os.path.exists 检查一个文件或者目录是否存在：
>>> os.path.exists('memo.txt')
True

# os.path.isdir 检查它是否是一个目录：
>>> os.path.isdir('memo.txt')
False
>>> os.path.isdir('music')
True

# os.path.isfile 检查是否是一个文件。
# os.listdir 返回给定目录下的文件（以及其他目录）：
>>> os.listdir(cwd)
['music', 'photos', 'memo.txt']


# 数据库 
# 数据库是用于存储数据的文件。大多数的数据库以字典的形式组织，即将键映射为值。
# 数据库是保存在磁盘（或其他永久存储设备）上，因此即使程序结束它们仍然存在。
# 模块 anydbm 提供了创建和跟新数据库文件的接口。
打开数据库和其他文件类似：
>>> import anydbm
>>> db = anydbm.open('captions.db', 'c')
模式'c' 代表如果文件不存在则创建文件。返回结果是一个数据库对象，它可以像字典一
样被使用（对于大多数的操作）。如果你创建一个新的项目，anydbm 将更新数据库文件。
>>> db['cleese.png'] = 'Photo of John Cleese.'
当你访问某个项目是，anydbm 将读取文件：
>>> print db['cleese.png']
Photo of John Cleese.
如果你对已有的键再次进行赋值，anydbm 将替代旧的值：
>>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
>>> print db['cleese.png']
Photo of John Cleese doing a silly walk.
许多字典的方法，如 keys 和 items，同样适用于数据库对象，包括使用 for 语句实现的
迭代：
for key in db:
print key
和其他文件一样，当你完成操作后你需要关闭文件：
>>> db.close()


# pickle 模块 能将任何类型的对象翻译成适合在数据库中储存的字符串，同时能将字符串还原成对象。
pickle.dumps 读取一个对象作为参数，并返回一个表征字符串（dumps 是“dump string”（转储字符串）的缩写）：
>>> import pickle
>>> t = [1, 2, 3]
>>> pickle.dumps(t)
'(lp0\nI1\naI2\naI3\na.'

这个格式对人类读者来说不是很好理解，但是对 pickle 来说很好解释。pickle.loads
（“载入字符串”）可以重建对象：
>>> t1 = [1, 2, 3]
>>> s = pickle.dumps(t1)
>>> t2 = pickle.loads(s)
>>> print t2
[1, 2, 3]
虽然新的对象和老的对象有相同的值，它们（通常）不是同一个对象：
>>> t1 == t2
True
>>> t1 is t2
False

```


# random随机数 概率 不确定性 掷骰子  玩扑克牌 

```python
>>>
```

# Turtle 小乌龟可视化编程模块
```python
>>>
```


